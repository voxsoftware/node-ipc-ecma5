/*global describe, expect, it*/
'use strict';

var ipc = require('../../../../node-ipc');

ipc.config.id = 'testClient';
ipc.config.retry = 600;

describe('Test Cases for Unix client: ', function UnixClientSpec() {
    it('Verify retry attempts by Unix client to connect to the Unix server as per the value set in "maxRetries" parameter.', function testIt(done) {

        ipc.config.maxRetries = 3;

        //set to -1 because there is an error on the first fail
        //before retrying
        var errorCount = -1;

        ipc.connectTo('fakeworld', function open() {
            ipc.of.fakeworld.on('error', function gotError(err) {
                errorCount++;
                expect(ipc.of.fakeworld.retriesRemaining).toBe(ipc.config.maxRetries - errorCount);
                expect(err).toBeDefined();
            });
        });

        setTimeout(function testDelay() {
            expect(errorCount).toBe(ipc.config.maxRetries);
            ipc.disconnect('fakeworld');
            done();
        }, ipc.config.retry * ipc.config.maxRetries + ipc.config.retry + ipc.config.retry);
    });

    it('Verify Unix client does not connect to the unix server when "stopRetrying" value is set to true.', function testIt(done) {

        ipc.config.maxRetries = 3;
        ipc.config.stopRetrying = true;
        ipc.silent = true;

        //set to -1 because there is an error on the first fail
        //before retrying
        var errorCount = -1;

        ipc.connectTo('fakeworld', function open() {

            ipc.of.fakeworld.on('error', function gotError(err) {
                expect(ipc.of.fakeworld.retriesRemaining).toBe(ipc.config.maxRetries);
                errorCount++;
                expect(err).toBeDefined();
            });
        });

        setTimeout(function testDelay() {
            expect(errorCount).toBe(0);
            expect(ipc.of.fakeworld.retriesRemaining).toBe(ipc.config.maxRetries);
            ipc.disconnect('fakeworld');
            done();
        }, ipc.config.retry * ipc.config.maxRetries);
    });

    it('Verify unix client connects to "unixServer" and receives message.', function testIt(done) {
        ipc.connectTo('unixServer', '/tmp/app.unixServer', function open() {
            ipc.of.unixServer.on('connect', function connected() {
                ipc.of.unixServer.on('message', function gotMessage(data) {
                    expect(data.id).toBe('unixServer');
                    expect(data.message).toBe('I am unix server!');
                    testDone();
                });

                ipc.of.unixServer.on('error', function gotErr(err) {
                    expect(err).toBe(false);
                    testDone();
                });

                ipc.of.unixServer.emit('message', {
                    id: ipc.config.id,
                    message: 'Hello from Client.'
                });
            });
        });

        function testDone() {
            ipc.disconnect('unixServer');
            done();
        }
    });

    it('Verify unix client queues the requests being sent to the server synchronously until it receives the response from server.', function testIt(done) {

        ipc.config.sync = true;
        var responseCounter = 0;

        ipc.connectTo('unixServerSync', '/tmp/app.unixServerSync', function open() {
            ipc.of.unixServerSync.on('connect', function connected() {

                for (var i = 0; i < 5; i++) {
                    ipc.of.unixServerSync.emit('message', {
                        id: ipc.config.id,
                        message: 'Unix Client Request '
                    });
                }

                ipc.of.unixServerSync.on('message', function gotMessage(data) {
                    expect(data.message).toBe('Response from unix server');
                    responseCounter++;

                    if (responseCounter < 5) {
                        return;
                    }
                    expect(responseCounter).toBe(5);
                    testDone();
                });

                ipc.of.unixServerSync.on('error', function testError(err) {
                    expect(err).toBe(false);
                    testDone();
                });
            });
        });

        function testDone() {
            ipc.disconnect('unixServerSync');
            done();
        }
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL25vZGUtaXBjL3NwZWMvc3VwcG9ydC9qYXNtaW5lVGVzdC9Vbml4L3VuaXhTb2NrZXRDbGllbnQuc3BlYy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUEsSUFBTSxNQUFNLFFBQVEsc0JBQVIsQ0FBTjs7QUFFTixJQUFJLE1BQUosQ0FBVyxFQUFYLEdBQWUsWUFBZjtBQUNBLElBQUksTUFBSixDQUFXLEtBQVgsR0FBbUIsR0FBbkI7O0FBRUEsU0FBUyw4QkFBVCxFQUNJLFNBQVMsY0FBVCxHQUF5QjtBQUNyQixPQUNJLG9IQURKLEVBRUksU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXFCOztBQUVqQixZQUFJLE1BQUosQ0FBVyxVQUFYLEdBQXdCLENBQXhCOzs7O0FBRmlCLFlBTWIsYUFBVyxDQUFDLENBQUQsQ0FORTs7QUFRakIsWUFBSSxTQUFKLENBQ0ksV0FESixFQUVJLFNBQVMsSUFBVCxHQUFlO0FBQ1gsZ0JBQUksRUFBSixDQUFPLFNBQVAsQ0FBaUIsRUFBakIsQ0FDSSxPQURKLEVBRUksU0FBUyxRQUFULENBQWtCLEdBQWxCLEVBQXNCO0FBQ2xCLDZCQURrQjtBQUVsQix1QkFBTyxJQUFJLEVBQUosQ0FBTyxTQUFQLENBQWlCLGdCQUFqQixDQUFQLENBQTBDLElBQTFDLENBQ0ksSUFBSSxNQUFKLENBQVcsVUFBWCxHQUFzQixVQUF0QixDQURKLENBRmtCO0FBS2xCLHVCQUFPLEdBQVAsRUFBWSxXQUFaLEdBTGtCO2FBQXRCLENBRkosQ0FEVztTQUFmLENBRkosQ0FSaUI7O0FBd0JqQixtQkFDSSxTQUFTLFNBQVQsR0FBb0I7QUFDaEIsbUJBQU8sVUFBUCxFQUFtQixJQUFuQixDQUF3QixJQUFJLE1BQUosQ0FBVyxVQUFYLENBQXhCLENBRGdCO0FBRWhCLGdCQUFJLFVBQUosQ0FBZSxXQUFmLEVBRmdCO0FBR2hCLG1CQUhnQjtTQUFwQixFQUtBLElBQUksTUFBSixDQUFXLEtBQVgsR0FBaUIsSUFB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O1NBQW5CO0tBakRKLENBRkosQ0E3SHFCO0NBQXpCLENBREoiLCJmaWxlIjoidW5peFNvY2tldENsaWVudC5zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgZGVzY3JpYmUsIGV4cGVjdCwgaXQqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpcGMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9ub2RlLWlwYycpO1xuXG5pcGMuY29uZmlnLmlkID0ndGVzdENsaWVudCc7XG5pcGMuY29uZmlnLnJldHJ5ID0gNjAwO1xuXG5kZXNjcmliZSgnVGVzdCBDYXNlcyBmb3IgVW5peCBjbGllbnQ6ICcsXG4gICAgZnVuY3Rpb24gVW5peENsaWVudFNwZWMoKXtcbiAgICAgICAgaXQoXG4gICAgICAgICAgICAnVmVyaWZ5IHJldHJ5IGF0dGVtcHRzIGJ5IFVuaXggY2xpZW50IHRvIGNvbm5lY3QgdG8gdGhlIFVuaXggc2VydmVyIGFzIHBlciB0aGUgdmFsdWUgc2V0IGluIFwibWF4UmV0cmllc1wiIHBhcmFtZXRlci4nLFxuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdEl0KGRvbmUpe1xuXG4gICAgICAgICAgICAgICAgaXBjLmNvbmZpZy5tYXhSZXRyaWVzID0gMztcblxuICAgICAgICAgICAgICAgIC8vc2V0IHRvIC0xIGJlY2F1c2UgdGhlcmUgaXMgYW4gZXJyb3Igb24gdGhlIGZpcnN0IGZhaWxcbiAgICAgICAgICAgICAgICAvL2JlZm9yZSByZXRyeWluZ1xuICAgICAgICAgICAgICAgIGxldCBlcnJvckNvdW50PS0xO1xuXG4gICAgICAgICAgICAgICAgaXBjLmNvbm5lY3RUbyhcbiAgICAgICAgICAgICAgICAgICAgJ2Zha2V3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9wZW4oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwYy5vZi5mYWtld29ybGQub24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnb3RFcnJvcihlcnIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChpcGMub2YuZmFrZXdvcmxkLnJldHJpZXNSZW1haW5pbmcpLnRvQmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGMuY29uZmlnLm1heFJldHJpZXMtZXJyb3JDb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoZXJyKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGVzdERlbGF5KCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoZXJyb3JDb3VudCkudG9CZShpcGMuY29uZmlnLm1heFJldHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBjLmRpc2Nvbm5lY3QoJ2Zha2V3b3JsZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpcGMuY29uZmlnLnJldHJ5KmlwYy5jb25maWcubWF4UmV0cmllcyArXG4gICAgICAgICAgICAgICAgICAgIGlwYy5jb25maWcucmV0cnkraXBjLmNvbmZpZy5yZXRyeVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaXQoXG4gICAgICAgICAgICAnVmVyaWZ5IFVuaXggY2xpZW50IGRvZXMgbm90IGNvbm5lY3QgdG8gdGhlIHVuaXggc2VydmVyIHdoZW4gXCJzdG9wUmV0cnlpbmdcIiB2YWx1ZSBpcyBzZXQgdG8gdHJ1ZS4nLFxuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdEl0KGRvbmUpe1xuXG4gICAgICAgICAgICAgICAgaXBjLmNvbmZpZy5tYXhSZXRyaWVzID0gMztcbiAgICAgICAgICAgICAgICBpcGMuY29uZmlnLnN0b3BSZXRyeWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXBjLnNpbGVudD10cnVlO1xuXG4gICAgICAgICAgICAgICAgLy9zZXQgdG8gLTEgYmVjYXVzZSB0aGVyZSBpcyBhbiBlcnJvciBvbiB0aGUgZmlyc3QgZmFpbFxuICAgICAgICAgICAgICAgIC8vYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yQ291bnQ9LTE7XG5cbiAgICAgICAgICAgICAgICBpcGMuY29ubmVjdFRvKFxuICAgICAgICAgICAgICAgICAgICAnZmFrZXdvcmxkJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3Blbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpcGMub2YuZmFrZXdvcmxkLm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ290RXJyb3IoZXJyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGlwYy5vZi5mYWtld29ybGQucmV0cmllc1JlbWFpbmluZykudG9CZShpcGMuY29uZmlnLm1heFJldHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChlcnIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXN0RGVsYXkoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChlcnJvckNvdW50KS50b0JlKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGlwYy5vZi5mYWtld29ybGQucmV0cmllc1JlbWFpbmluZykudG9CZShpcGMuY29uZmlnLm1heFJldHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBjLmRpc2Nvbm5lY3QoJ2Zha2V3b3JsZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpcGMuY29uZmlnLnJldHJ5KmlwYy5jb25maWcubWF4UmV0cmllc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cblxuICAgICAgICBpdChcbiAgICAgICAgICAgICdWZXJpZnkgdW5peCBjbGllbnQgY29ubmVjdHMgdG8gXCJ1bml4U2VydmVyXCIgYW5kIHJlY2VpdmVzIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RJdChkb25lKXtcbiAgICAgICAgICAgICAgICBpcGMuY29ubmVjdFRvKFxuICAgICAgICAgICAgICAgICAgICAndW5peFNlcnZlcicsXG4gICAgICAgICAgICAgICAgICAgICcvdG1wL2FwcC51bml4U2VydmVyJyxcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9wZW4oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpcGMub2YudW5peFNlcnZlci5vbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29ubmVjdGVkKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwYy5vZi51bml4U2VydmVyLm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ290TWVzc2FnZShkYXRhKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoZGF0YS5pZCkudG9CZSgndW5peFNlcnZlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChkYXRhLm1lc3NhZ2UpLnRvQmUoJ0kgYW0gdW5peCBzZXJ2ZXIhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdERvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGMub2YudW5peFNlcnZlci5vbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnb3RFcnIoZXJyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoZXJyKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0RG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwYy5vZi51bml4U2VydmVyLmVtaXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IGlwYy5jb25maWcuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6ICdIZWxsbyBmcm9tIENsaWVudC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGVzdERvbmUoKXtcbiAgICAgICAgICAgICAgICAgICAgaXBjLmRpc2Nvbm5lY3QoJ3VuaXhTZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpdChcbiAgICAgICAgICAgICdWZXJpZnkgdW5peCBjbGllbnQgcXVldWVzIHRoZSByZXF1ZXN0cyBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXIgc3luY2hyb25vdXNseSB1bnRpbCBpdCByZWNlaXZlcyB0aGUgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RJdChkb25lKXtcblxuICAgICAgICAgICAgICAgIGlwYy5jb25maWcuc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlQ291bnRlciA9IDA7XG5cbiAgICAgICAgICAgICAgICBpcGMuY29ubmVjdFRvKFxuICAgICAgICAgICAgICAgICAgICAndW5peFNlcnZlclN5bmMnLFxuICAgICAgICAgICAgICAgICAgICAnL3RtcC9hcHAudW5peFNlcnZlclN5bmMnLFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3Blbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlwYy5vZi51bml4U2VydmVyU3luYy5vbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29ubmVjdGVkKCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8NTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwYy5vZi51bml4U2VydmVyU3luYy5lbWl0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBpcGMuY29uZmlnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogJ1VuaXggQ2xpZW50IFJlcXVlc3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGMub2YudW5peFNlcnZlclN5bmMub24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnb3RNZXNzYWdlKGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChkYXRhLm1lc3NhZ2UpLnRvQmUoJ1Jlc3BvbnNlIGZyb20gdW5peCBzZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUNvdW50ZXIgPCA1KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QocmVzcG9uc2VDb3VudGVyKS50b0JlKDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3REb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXBjLm9mLnVuaXhTZXJ2ZXJTeW5jLm9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RFcnJvcihlcnIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChlcnIpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3REb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGVzdERvbmUoKXtcbiAgICAgICAgICAgICAgICAgICAgaXBjLmRpc2Nvbm5lY3QoJ3VuaXhTZXJ2ZXJTeW5jJyk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuKTtcbiJdfQ==